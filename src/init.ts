import { resolve } from "node:path";
import type { CommandSpec, ServiceConfig } from "./types";

export class InitError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "InitError";
  }
}

type InitResult = {
  manifestPath: string;
  services: ServiceConfig[];
  warnings: string[];
};

const fileExists = async (path: string): Promise<boolean> => {
  try {
    return await Bun.file(path).exists();
  } catch {
    return false;
  }
};

const detectPackageManager = async (cwd: string): Promise<string> => {
  if (await fileExists(resolve(cwd, "bun.lockb"))) return "bun";
  if (await fileExists(resolve(cwd, "bun.lock"))) return "bun";
  if (await fileExists(resolve(cwd, "pnpm-lock.yaml"))) return "pnpm";
  if (await fileExists(resolve(cwd, "yarn.lock"))) return "yarn";
  if (await fileExists(resolve(cwd, "package-lock.json"))) return "npm";
  return "bun";
};

const readPackageScripts = async (cwd: string): Promise<Record<string, string> | null> => {
  const path = resolve(cwd, "package.json");
  if (!(await fileExists(path))) return null;
  const contents = await Bun.file(path).text();
  try {
    const parsed = JSON.parse(contents) as { scripts?: Record<string, string> };
    return parsed.scripts ?? {};
  } catch {
    return null;
  }
};

const pickScript = (scripts: Record<string, string>): string | null => {
  const order = ["dev", "start", "watch", "serve"];
  for (const name of order) {
    if (scripts[name]) return name;
  }
  return null;
};

const ensureUniqueName = (name: string, used: Set<string>): string => {
  if (!used.has(name)) return name;
  let suffix = 2;
  while (used.has(`${name}-${suffix}`)) {
    suffix += 1;
  }
  return `${name}-${suffix}`;
};

const escapeToml = (value: string): string => value.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");

const formatCommand = (command: CommandSpec): string => {
  if (Array.isArray(command)) return command.join(" ");
  return command;
};

const renderManifest = (services: ServiceConfig[]): string => {
  const lines: string[] = [];
  lines.push("# stasium.toml");
  lines.push("# Generated by `stasium init`");
  lines.push("");

  if (services.length === 0) {
    lines.push("# No services detected. Add [[service]] blocks below.");
    lines.push("#");
    lines.push("# [[service]]");
    lines.push("# name = \"app\"");
    lines.push("# command = [\"php\", \"artisan\", \"serve\"]");
    lines.push("# working_dir = \".\"");
    lines.push("");
    return lines.join("\n");
  }

  for (const service of services) {
    lines.push("[[service]]");
    lines.push(`name = \"${escapeToml(service.name)}\"`);
    const command = Array.isArray(service.command)
      ? `[${service.command.map((part) => `\"${escapeToml(part)}\"`).join(", ")}]`
      : `\"${escapeToml(service.command)}\"`;
    lines.push(`command = ${command}`);
    if (service.working_dir) {
      lines.push(`working_dir = \"${escapeToml(service.working_dir)}\"`);
    }
    lines.push("");
  }

  return lines.join("\n");
};

export const initProject = async (cwd: string, manifestName = "stasium.toml"): Promise<InitResult> => {
  const manifestPath = resolve(cwd, manifestName);
  if (await fileExists(manifestPath)) {
    throw new InitError(`Manifest already exists: ${manifestPath}`);
  }

  const services: ServiceConfig[] = [];
  const warnings: string[] = [];
  const usedNames = new Set<string>();

  const artisanPath = resolve(cwd, "artisan");
  const hasArtisan = await fileExists(artisanPath);
  if (hasArtisan) {
    const name = ensureUniqueName("app", usedNames);
    usedNames.add(name);
    services.push({
      name,
      command: ["php", "artisan", "serve"],
      working_dir: ".",
    });

    const queueConfig = resolve(cwd, "config/queue.php");
    if (await fileExists(queueConfig)) {
      const queueName = ensureUniqueName("queue", usedNames);
      usedNames.add(queueName);
      services.push({
        name: queueName,
        command: ["php", "artisan", "queue:work"],
        working_dir: ".",
      });
    }
  }

  const scripts = await readPackageScripts(cwd);
  if (scripts) {
    const script = pickScript(scripts);
    if (script) {
      const packageManager = await detectPackageManager(cwd);
      const name = ensureUniqueName("frontend", usedNames);
      usedNames.add(name);
      services.push({
        name,
        command: [packageManager, "run", script],
        working_dir: ".",
      });
    }
  } else if (await fileExists(resolve(cwd, "package.json"))) {
    warnings.push("package.json exists but could not be parsed. Frontend service skipped.");
  }

  const manifestContents = renderManifest(services);
  await Bun.write(manifestPath, manifestContents);

  return {
    manifestPath,
    services,
    warnings,
  };
};

export const formatServiceSummary = (service: ServiceConfig): string =>
  `${service.name}: ${formatCommand(service.command)}`;
